import { a as __toESM } from "./chunk-C3fVp-vY.js";
import { t as require_react } from "./react-D_ztdoUO.js";

//#region node_modules/@pbe/react-yandex-maps/dist/react-yandex-maps.esm.js
var import_react = /* @__PURE__ */ __toESM(require_react());
function r() {
	return r = Object.assign ? Object.assign.bind() : function(t$1) {
		for (var e$1 = 1; e$1 < arguments.length; e$1++) {
			var n$1 = arguments[e$1];
			for (var o$1 in n$1) Object.prototype.hasOwnProperty.call(n$1, o$1) && (t$1[o$1] = n$1[o$1]);
		}
		return t$1;
	}, r.apply(this, arguments);
}
var a = (t$1, e$1) => {
	const n$1 = {};
	for (const o$1 in t$1) -1 === e$1.indexOf(o$1) && (n$1[o$1] = t$1[o$1]);
	return n$1;
}, i = /* @__PURE__ */ import_react.createContext(null), c = /* @__PURE__ */ import_react.createContext(null), l = (e$1) => (n$1) => /* @__PURE__ */ import_react.createElement(c.Consumer, null, (o$1) => /* @__PURE__ */ import_react.createElement(e$1, r({ parent: o$1 }, n$1))), p = (t$1 = []) => {
	const [r$1, a$1] = (0, import_react.useState)(!1), c$1 = (0, import_react.useRef)(t$1), l$1 = (() => {
		const t$2 = (0, import_react.useContext)(i);
		if (null === t$2) throw new Error("Couldn't find Yandex.Maps API in the context. Make sure that hook useYMaps is inside <YMaps /> provider");
		return t$2;
	})(), p$1 = l$1.getApi();
	return (0, import_react.useEffect)(() => {
		l$1.load().then(() => Promise.all(c$1.current.map(l$1.loadModule))).then(() => a$1(!0));
	}, []), r$1 && p$1 ? p$1 : null;
}, u = () => {}, m = [
	"onLoad",
	"onError",
	"modules",
	"apiLoader"
];
function d(e$1, n$1 = !1, o$1 = []) {
	return (i$1) => {
		const { width: c$1, height: l$1, modules: d$1 = [], onLoad: h$1 = u } = i$1, f$1 = p(o$1.concat(d$1)), y$1 = !n$1 || !!f$1, b$1 = a(i$1, m);
		return (0, import_react.useEffect)(() => f$1 ? h$1(f$1) : void 0, [f$1]), y$1 ? /* @__PURE__ */ import_react.createElement(e$1, r({ ymaps: f$1 }, b$1)) : /* @__PURE__ */ import_react.createElement("div", { style: {
			width: c$1,
			height: l$1
		} });
	};
}
var h = "undefined" != typeof window, f = {
	lang: "ru_RU",
	load: "",
	ns: "",
	mode: "release"
}, y = (e$1) => {
	const { version: n$1 = "2.1", enterprise: r$1 = !1, query: a$1 = {
		lang: "ru_RU",
		load: "",
		ns: ""
	}, preload: c$1 = !1, children: l$1 } = e$1, p$1 = (0, import_react.useRef)(((t$1) => {
		const { query: e$2 = f } = t$1, n$2 = Date.now().toString(32), o$1 = e$2.ns || "", s$1 = "__yandex-maps-api-onload__$$" + n$2, r$2 = "__yandex-maps-api-onerror__$$" + n$2, a$2 = h ? window : {}, i$1 = {};
		let c$2;
		const l$2 = () => o$1 ? a$2[o$1] : c$2, p$2 = () => {
			delete a$2[s$1], delete a$2[r$2];
		};
		return {
			load: () => {
				if (l$2()) return Promise.resolve(c$2);
				if (i$1[o$1]) return i$1[o$1];
				const n$3 = {
					onload: s$1,
					onerror: r$2,
					...f,
					...e$2
				}, u$1 = Object.keys(n$3).map((t$2) => `${t$2}=${n$3[t$2]}`).join("&"), m$1 = [
					`https://${t$1.enterprise ? "enterprise." : ""}api-maps.yandex.ru`,
					t$1.version,
					"?" + u$1
				].join("/");
				return i$1[o$1] = new Promise((t$2, e$3) => {
					a$2[s$1] = (e$4) => {
						p$2(), e$4.ready(() => {
							c$2 = e$4, t$2(e$4);
						});
					}, a$2[r$2] = (t$3) => {
						p$2(), e$3(t$3);
					}, ((t$3) => new Promise((e$4, n$4) => {
						const o$2 = document.createElement("script");
						o$2.type = "text/javascript", o$2.onload = e$4, o$2.onerror = n$4, o$2.src = t$3, o$2.async = !0, document.head.appendChild(o$2);
					}))(m$1).catch(a$2[r$2]);
				}), i$1[o$1];
			},
			getApi: l$2,
			loadModule: (t$2) => new Promise((e$3, n$3) => {
				c$2.modules.require(t$2).done((n$4) => {
					n$4.forEach((e$4) => {
						((t$3, e$5, n$5, o$2 = !1) => {
							const s$2 = "string" == typeof e$5 ? e$5.split(".") : e$5.slice();
							let r$3, a$3 = t$3;
							for (; s$2.length > 1;) r$3 = s$2.shift(), a$3[r$3] || (a$3[r$3] = {}), a$3 = a$3[r$3];
							const i$2 = s$2[0];
							a$3[i$2] = !0 === o$2 && a$3[i$2] || n$5;
						})(c$2, t$2, e$4, !0);
					}), e$3(c$2);
				}, n$3);
			})
		};
	})({
		version: n$1,
		enterprise: r$1,
		query: a$1,
		preload: c$1
	}));
	return (0, import_react.useEffect)(() => {
		c$1 && p$1.current.load();
	}, [p$1.current]), /* @__PURE__ */ import_react.createElement(i.Provider, { value: p$1.current }, l$1);
}, b = /^on(?=[A-Z])/;
function v(t$1) {
	return Object.keys(t$1).reduce((e$1, n$1) => {
		if (b.test(n$1)) {
			const o$1 = n$1.replace(b, "").toLowerCase();
			e$1._events[o$1] = t$1[n$1];
		} else e$1[n$1] = t$1[n$1];
		return e$1;
	}, { _events: {} });
}
function j(t$1, e$1, n$1) {
	"function" == typeof n$1 && t$1.events.add(e$1, n$1);
}
function O(t$1, e$1, n$1) {
	"function" == typeof n$1 && t$1.events.remove(e$1, n$1);
}
function g(t$1, e$1, n$1) {
	Object.keys(Object.assign({}, e$1, n$1)).forEach((o$1) => {
		e$1[o$1] !== n$1[o$1] && (O(t$1, o$1, e$1[o$1]), j(t$1, o$1, n$1[o$1]));
	});
}
var E = (t$1) => "default" + t$1.charAt(0).toUpperCase() + t$1.slice(1);
function C(t$1, e$1) {
	return void 0 !== t$1[e$1] || void 0 === t$1[E(e$1)];
}
function _(t$1, e$1, n$1) {
	return (C(t$1, e$1) ? t$1[e$1] : t$1[E(e$1)]) || n$1;
}
function R(t$1, e$1, n$1 = null) {
	if (t$1 !== e$1) {
		if (t$1 && ("current" in t$1 ? t$1.current = null : "function" == typeof t$1 && t$1(null)), !e$1) return;
		"current" in e$1 ? e$1.current = n$1 : "function" == typeof e$1 && e$1(n$1);
	}
}
function w(t$1) {
	const { width: e$1, height: n$1, style: o$1, className: s$1 } = t$1;
	return void 0 !== o$1 || void 0 !== s$1 ? Object.assign({}, o$1 && { style: o$1 }, s$1 && { className: s$1 }) : { style: {
		width: e$1,
		height: n$1
	} };
}
var P = class extends import_react.Component {
	constructor(t$1) {
		super(t$1), this.state = {
			error: null,
			errorInfo: null
		};
	}
	componentDidCatch(t$1, e$1) {
		const { onError: n$1 = (() => {}) } = this.props;
		n$1(t$1), this.setState({
			error: t$1,
			errorInfo: e$1
		});
	}
	render() {
		return this.state.error ? null : this.props.children;
	}
};
var x = (e$1) => ({ onError: n$1, ...o$1 }) => /* @__PURE__ */ import_react.createElement(P, { onError: n$1 }, /* @__PURE__ */ import_react.createElement(e$1, o$1));
var M = class M extends import_react.Component {
	constructor() {
		super(), this.instance = null, this.state = { instance: null }, this._parentElement = null, this._getRef = (t$1) => {
			this._parentElement = t$1;
		};
	}
	componentDidMount() {
		this.instance = M.mountObject(this._parentElement, this.props.ymaps.Map, this.props), this.setState({ instance: this.instance });
	}
	componentDidUpdate(t$1) {
		null !== this.instance && M.updateObject(this.instance, t$1, this.props);
	}
	componentWillUnmount() {
		M.unmountObject(this.instance, this.props);
	}
	render() {
		const e$1 = w(this.props), o$1 = a(v(this.props), [
			"_events",
			"state",
			"defaultState",
			"options",
			"defaultOptions",
			"instanceRef",
			"ymaps",
			"children",
			"width",
			"height",
			"style",
			"className"
		]);
		return import_react.createElement(c.Provider, { value: this.state.instance }, /* @__PURE__ */ import_react.createElement("div", r({ ref: this._getRef }, e$1, o$1), this.props.children));
	}
	static mountObject(t$1, e$1, n$1) {
		const { instanceRef: o$1, _events: s$1 } = v(n$1), r$1 = new e$1(t$1, _(n$1, "state"), _(n$1, "options"));
		return Object.keys(s$1).forEach((t$2) => j(r$1, t$2, s$1[t$2])), R(null, o$1, r$1), r$1;
	}
	static updateObject(t$1, e$1, n$1) {
		const { _events: o$1, instanceRef: s$1 } = v(n$1), { _events: r$1, instanceRef: a$1 } = v(e$1);
		if (C(n$1, "state")) {
			const o$2 = _(e$1, "state", {}), s$2 = _(n$1, "state", {});
			o$2.type !== s$2.type && t$1.setType(s$2.type), o$2.behaviors !== s$2.behaviors && (o$2.behaviors && t$1.behaviors.disable(o$2.behaviors), s$2.behaviors && t$1.behaviors.enable(s$2.behaviors)), s$2.zoom && o$2.zoom !== s$2.zoom && t$1.setZoom(s$2.zoom), s$2.center && o$2.center !== s$2.center && t$1.setCenter(s$2.center), s$2.bounds && o$2.bounds !== s$2.bounds && t$1.setBounds(s$2.bounds);
		}
		if (C(n$1, "options")) {
			const o$2 = _(e$1, "options"), s$2 = _(n$1, "options", {});
			o$2 !== s$2 && t$1.options.set(s$2);
		}
		_(e$1, "width") === _(n$1, "width") && _(e$1, "height") === _(n$1, "height") || t$1.container.fitToViewport(), g(t$1, r$1, o$1), R(a$1, s$1, t$1);
	}
	static unmountObject(t$1, e$1) {
		const { instanceRef: n$1, _events: o$1 } = v(e$1);
		null !== t$1 && (Object.keys(o$1).forEach((e$2) => O(t$1, e$2, o$1[e$2])), t$1.destroy(), R(n$1));
	}
};
var k = x(d(M, !0, ["Map"]));
k.defaultProps = {
	width: 320,
	height: 240
};
var S = class S extends import_react.Component {
	constructor() {
		super(), this.state = { instance: null }, this._parentElement = null, this._getRef = (t$1) => {
			this._parentElement = t$1;
		};
	}
	componentDidMount() {
		this._mounted = !0, this.props.ymaps.panorama.isSupported() && S.mountObject(this._parentElement, this.props.ymaps.panorama, this.props).then((t$1) => this._mounted && this.setState({ instance: t$1 }));
	}
	componentDidUpdate(t$1) {
		null !== this.state.instance && S.updateObject(this.state.instance, t$1, this.props);
	}
	componentWillUnmount() {
		this._mounted = !1, S.unmountObject(this.state.instance, this.props);
	}
	render() {
		const e$1 = w(this.props);
		return import_react.createElement("div", r({ ref: this._getRef }, e$1));
	}
	static mountObject(t$1, e$1, n$1) {
		const { instanceRef: o$1, _events: s$1 } = v(n$1), r$1 = _(n$1, "point"), a$1 = _(n$1, "locateOptions"), i$1 = _(n$1, "options");
		return new Promise((n$2, c$1) => {
			e$1.locate(r$1, a$1).done((r$2) => {
				if (r$2.length > 0) {
					const a$2 = new e$1.Player(t$1, r$2[0], i$1);
					R(null, o$1, a$2), Object.keys(s$1).forEach((t$2) => j(a$2, t$2, s$1[t$2])), n$2(a$2);
				}
			}, c$1);
		});
	}
	static updateObject(t$1, e$1, n$1) {
		const { _events: o$1, instanceRef: s$1 } = v(n$1), { _events: r$1, instanceRef: a$1 } = v(e$1);
		if (C(n$1, "options")) {
			const o$2 = _(e$1, "options"), s$2 = _(n$1, "options");
			o$2 !== s$2 && t$1.options.set(s$2);
		}
		if (C(n$1, "point")) {
			const o$2 = _(n$1, "point"), s$2 = _(e$1, "point"), r$2 = _(n$1, "locateOptions");
			o$2 !== s$2 && t$1.moveTo(o$2, r$2);
		}
		g(t$1, r$1, o$1), R(a$1, s$1, t$1);
	}
	static unmountObject(t$1, e$1) {
		const { instanceRef: n$1, _events: o$1 } = v(e$1);
		null !== t$1 && (Object.keys(o$1).forEach((e$2) => O(t$1, e$2, o$1[e$2])), R(n$1));
	}
};
var T = x(d(S, !0, [
	"panorama.isSupported",
	"panorama.locate",
	"panorama.createPlayer",
	"panorama.Player"
]));
T.defaultProps = {
	width: 320,
	height: 240
};
var U = class U extends import_react.Component {
	constructor() {
		super(), this.state = { instance: null }, this.instance = null;
	}
	componentDidMount() {
		const t$1 = U.mountControl(this.props.ymaps.control[this.props.name], this.props);
		this.instance = t$1, this.setState({ instance: t$1 });
	}
	componentDidUpdate(t$1) {
		null !== this.instance && U.updateControl(this.instance, t$1, this.props);
	}
	componentWillUnmount() {
		U.unmountControl(this.instance, this.props);
	}
	render() {
		return import_react.createElement(c.Provider, { value: this.state.instance }, this.props.children);
	}
	static mountControl(t$1, e$1) {
		const { instanceRef: n$1, parent: o$1, lazy: s$1, _events: r$1 } = v(e$1), a$1 = new t$1({
			data: _(e$1, "data"),
			options: _(e$1, "options"),
			state: _(e$1, "state"),
			mapTypes: _(e$1, "mapTypes"),
			lazy: s$1
		});
		if (Object.keys(r$1).forEach((t$2) => j(a$1, t$2, r$1[t$2])), o$1 && o$1.controls && "function" == typeof o$1.controls.add) o$1.controls.add(a$1);
		else {
			if (!o$1 || !o$1.add || "function" != typeof o$1.add) throw new Error(`No parent found to mount ${e$1.name}`);
			o$1.add(a$1);
		}
		return R(null, n$1, a$1), a$1;
	}
	static updateControl(t$1, e$1, n$1) {
		const { _events: o$1, instanceRef: s$1 } = v(n$1), { _events: r$1, instanceRef: a$1 } = v(e$1);
		if (C(n$1, "options")) {
			const o$2 = _(e$1, "options"), s$2 = _(n$1, "options");
			o$2 !== s$2 && t$1.options.set(s$2);
		}
		if (C(n$1, "data")) {
			const o$2 = _(e$1, "data"), s$2 = _(n$1, "data");
			o$2 !== s$2 && t$1.data.set(s$2);
		}
		if (C(n$1, "state")) {
			const o$2 = _(e$1, "state"), s$2 = _(n$1, "state");
			o$2 !== s$2 && t$1.state.set(s$2);
		}
		if (C(n$1, "mapTypes")) {
			const o$2 = _(e$1, "mapTypes"), s$2 = _(n$1, "mapTypes");
			o$2 !== s$2 && (t$1.removeAllMapTypes(), s$2.forEach((e$2) => t$1.addMapType(e$2)));
		}
		g(t$1, r$1, o$1), R(a$1, s$1, t$1);
	}
	static unmountControl(t$1, e$1) {
		const { instanceRef: n$1, parent: o$1, _events: s$1 } = v(e$1);
		null !== t$1 && (Object.keys(s$1).forEach((e$2) => O(t$1, e$2, s$1[e$2])), o$1.controls && "function" == typeof o$1.controls.remove ? o$1.controls.remove(t$1) : o$1.remove && "function" == typeof o$1.remove && o$1.remove(t$1), R(n$1));
	}
};
var D = x(l(d((e$1) => /* @__PURE__ */ import_react.createElement(U, r({}, e$1, { name: "Button" })), !0, ["control.Button"]))), B = x(l(d((e$1) => /* @__PURE__ */ import_react.createElement(U, r({}, e$1, { name: "FullscreenControl" })), !0, ["control.FullscreenControl"]))), A = x(l(d((e$1) => /* @__PURE__ */ import_react.createElement(U, r({}, e$1, { name: "GeolocationControl" })), !0, ["control.GeolocationControl"]))), L = x(l(d((e$1) => /* @__PURE__ */ import_react.createElement(U, r({}, e$1, { name: "ListBox" })), !0, ["control.ListBox"]))), $ = x(l(d((e$1) => /* @__PURE__ */ import_react.createElement(U, r({}, e$1, { name: "ListBoxItem" })), !0, ["control.ListBoxItem"]))), N = x(l(d((e$1) => /* @__PURE__ */ import_react.createElement(U, r({}, e$1, { name: "RouteButton" })), !0, ["control.RouteButton"]))), Z = x(l(d((e$1) => /* @__PURE__ */ import_react.createElement(U, r({}, e$1, { name: "RouteEditor" })), !0, ["control.RouteEditor"]))), z = x(l(d((e$1) => /* @__PURE__ */ import_react.createElement(U, r({}, e$1, { name: "RoutePanel" })), !0, ["control.RoutePanel"]))), G = x(l(d((e$1) => /* @__PURE__ */ import_react.createElement(U, r({}, e$1, { name: "RulerControl" })), !0, ["control.RulerControl"]))), I = x(l(d((e$1) => /* @__PURE__ */ import_react.createElement(U, r({}, e$1, { name: "SearchControl" })), !0, ["control.SearchControl"]))), W = x(l(d((e$1) => /* @__PURE__ */ import_react.createElement(U, r({}, e$1, { name: "TrafficControl" })), !0, ["control.TrafficControl"]))), F = x(l(d((e$1) => /* @__PURE__ */ import_react.createElement(U, r({}, e$1, { name: "TypeSelector" })), !0, ["control.TypeSelector"]))), q = x(l(d((e$1) => /* @__PURE__ */ import_react.createElement(U, r({}, e$1, { name: "ZoomControl" })), !0, ["control.ZoomControl"])));
var Y = class Y extends import_react.Component {
	constructor() {
		super(), this.state = { instance: null }, this.instance = null;
	}
	componentDidMount() {
		const t$1 = Y.mountObject(this.props.ymaps.Clusterer, this.props);
		this.instance = t$1, this.setState({ instance: t$1 });
	}
	componentDidUpdate(t$1) {
		null !== this.state.instance && Y.updateObject(this.instance, t$1, this.props);
	}
	componentWillUnmount() {
		Y.unmountObject(this.instance, this.props);
	}
	render() {
		return import_react.createElement(c.Provider, { value: this.state.instance }, this.props.children);
	}
	static mountObject(t$1, e$1) {
		const { instanceRef: n$1, parent: o$1, _events: s$1 } = v(e$1), r$1 = new t$1(_(e$1, "options"));
		if (Object.keys(s$1).forEach((t$2) => j(r$1, t$2, s$1[t$2])), o$1.geoObjects && "function" == typeof o$1.geoObjects.add) o$1.geoObjects.add(r$1);
		else {
			if (!o$1.add || "function" != typeof o$1.add) throw new Error("No parent found to mount Clusterer");
			o$1.add(r$1);
		}
		return R(null, n$1, r$1), r$1;
	}
	static updateObject(t$1, e$1, n$1) {
		const { _events: o$1, instanceRef: s$1 } = v(n$1), { _events: r$1, instanceRef: a$1 } = v(e$1);
		if (C(n$1, "options")) {
			const o$2 = _(e$1, "options"), s$2 = _(n$1, "options");
			o$2 !== s$2 && t$1.options.set(s$2);
		}
		g(t$1, r$1, o$1), R(a$1, s$1, t$1);
	}
	static unmountObject(t$1, e$1) {
		const { instanceRef: n$1, parent: o$1, _events: s$1 } = v(e$1);
		null !== t$1 && (Object.keys(s$1).forEach((e$2) => O(t$1, e$2, s$1[e$2])), o$1.geoObjects && "function" == typeof o$1.geoObjects.remove ? o$1.geoObjects.remove(t$1) : o$1.remove && "function" == typeof o$1.remove && o$1.remove(t$1), R(n$1));
	}
};
var V = x(l(d(Y, !0, ["Clusterer"])));
var H = class H extends import_react.Component {
	constructor() {
		super(), this.state = { instance: null };
	}
	componentDidMount() {
		const t$1 = H.mountObject(this.props.ymaps.ObjectManager, this.props);
		this.instance = t$1, this.setState({ instance: t$1 });
	}
	componentDidUpdate(t$1) {
		null !== this.instance && H.updateObject(this.instance, t$1, this.props);
	}
	componentWillUnmount() {
		H.unmountObject(this.instance, this.props);
	}
	render() {
		return null;
	}
	static mountObject(t$1, e$1) {
		const { instanceRef: n$1, parent: o$1, _events: s$1 } = v(e$1), r$1 = _(e$1, "options", {}), a$1 = _(e$1, "features", {}), i$1 = _(e$1, "filter", null), c$1 = _(e$1, "objects", {}), l$1 = _(e$1, "clusters", {}), p$1 = new t$1(r$1);
		if (p$1.add(a$1 || []), p$1.setFilter(i$1), p$1.objects.options.set(c$1), p$1.clusters.options.set(l$1), Object.keys(s$1).forEach((t$2) => j(p$1, t$2, s$1[t$2])), o$1.geoObjects && "function" == typeof o$1.geoObjects.add) o$1.geoObjects.add(p$1);
		else {
			if (!o$1.add || "function" != typeof o$1.add) throw new Error("No parent found to mount ObjectManager");
			o$1.add(p$1);
		}
		return R(null, n$1, p$1), p$1;
	}
	static updateObject(t$1, e$1, n$1) {
		const { _events: o$1, instanceRef: s$1 } = v(n$1), { _events: r$1, instanceRef: a$1 } = v(e$1);
		if (C(n$1, "options")) {
			const o$2 = _(e$1, "options"), s$2 = _(n$1, "options");
			o$2 !== s$2 && t$1.options.set(s$2);
		}
		if (C(n$1, "objects")) {
			const o$2 = _(e$1, "objects"), s$2 = _(n$1, "objects");
			o$2 !== s$2 && t$1.objects.options.set(s$2);
		}
		if (C(n$1, "clusters")) {
			const o$2 = _(e$1, "clusters"), s$2 = _(n$1, "clusters");
			o$2 !== s$2 && t$1.clusters.options.set(s$2);
		}
		if (C(n$1, "filter")) {
			const o$2 = _(e$1, "filter"), s$2 = _(n$1, "filter");
			o$2 !== s$2 && t$1.setFilter(s$2);
		}
		if (C(n$1, "features")) {
			const o$2 = _(e$1, "features"), s$2 = _(n$1, "features");
			o$2 !== s$2 && (t$1.remove(o$2), t$1.add(s$2));
		}
		g(t$1, r$1, o$1), R(a$1, s$1, t$1);
	}
	static unmountObject(t$1, e$1) {
		const { instanceRef: n$1, parent: o$1, _events: s$1 } = v(e$1);
		null !== t$1 && (Object.keys(s$1).forEach((e$2) => O(t$1, e$2, s$1[e$2])), o$1.geoObjects && "function" == typeof o$1.geoObjects.remove ? o$1.geoObjects.remove(t$1) : o$1.remove && "function" == typeof o$1.remove && o$1.remove(t$1), R(n$1));
	}
};
var J = x(l(d(H, !0, ["ObjectManager"])));
var K = class K extends import_react.Component {
	constructor() {
		super(), this.state = { instance: null }, this.instance = null;
	}
	componentDidMount() {
		const { name: t$1, ymaps: e$1, dangerZone: n$1 } = this.props, o$1 = K.mountObject(n$1 && "function" == typeof n$1.modifyConstructor ? n$1.modifyConstructor(e$1[t$1]) : e$1[t$1], this.props);
		this.instance = o$1, this.setState({ instance: o$1 });
	}
	componentDidUpdate(t$1) {
		null !== this.instance && K.updateObject(this.instance, t$1, this.props);
	}
	componentWillUnmount() {
		K.unmountObject(this.instance, this.props);
	}
	render() {
		return null;
	}
	static mountObject(t$1, e$1) {
		const { instanceRef: n$1, parent: o$1, _events: s$1 } = v(e$1), r$1 = new t$1(_(e$1, "geometry"), _(e$1, "properties"), _(e$1, "options"));
		if (Object.keys(s$1).forEach((t$2) => j(r$1, t$2, s$1[t$2])), o$1 && o$1.geoObjects && "function" == typeof o$1.geoObjects.add) o$1.geoObjects.add(r$1);
		else {
			if (!o$1 || !o$1.add || "function" != typeof o$1.add) throw new Error(`No parent found to mount ${e$1.name}`);
			o$1.add(r$1);
		}
		return R(null, n$1, r$1), r$1;
	}
	static updateObject(t$1, e$1, n$1) {
		const { _events: o$1, instanceRef: s$1 } = v(n$1), { _events: r$1, instanceRef: a$1 } = v(e$1);
		if (C(n$1, "geometry")) {
			const o$2 = _(e$1, "geometry", {}), s$2 = _(n$1, "geometry", {});
			Array.isArray(s$2) && s$2 !== o$2 ? Array.isArray(s$2[0]) && "number" == typeof s$2[1] ? (t$1.geometry.setCoordinates(s$2[0]), t$1.geometry.setRadius(s$2[1])) : t$1.geometry.setCoordinates(s$2) : "object" == typeof s$2 && (s$2.coordinates !== o$2.coordinates && t$1.geometry.setCoordinates(s$2.coordinates), s$2.radius !== o$2.radius && t$1.geometry.setRadius(s$2.radius));
		}
		if (C(n$1, "properties")) {
			const o$2 = _(e$1, "properties"), s$2 = _(n$1, "properties");
			o$2 !== s$2 && t$1.properties.set(s$2);
		}
		if (C(n$1, "options")) {
			const o$2 = _(e$1, "options"), s$2 = _(n$1, "options");
			o$2 !== s$2 && t$1.options.set(s$2);
		}
		g(t$1, r$1, o$1), R(a$1, s$1, t$1);
	}
	static unmountObject(t$1, e$1) {
		const { instanceRef: n$1, parent: o$1, _events: s$1 } = v(e$1);
		null !== t$1 && (Object.keys(s$1).forEach((e$2) => O(t$1, e$2, s$1[e$2])), o$1.geoObjects && "function" == typeof o$1.geoObjects.remove ? o$1.geoObjects.remove(t$1) : o$1.remove && "function" == typeof o$1.remove && o$1.remove(t$1), R(n$1));
	}
};
var Q = { modifyConstructor(t$1) {
	function e$1(e$2, n$1, o$1) {
		t$1.call(this, {
			geometry: e$2,
			properties: n$1
		}, o$1);
	}
	return e$1.prototype = t$1.prototype, e$1;
} };
var X = x(l(d((e$1) => /* @__PURE__ */ import_react.createElement(K, r({}, e$1, {
	name: "GeoObject",
	dangerZone: Q
})), !0, ["GeoObject"]))), tt = x(l(d((e$1) => /* @__PURE__ */ import_react.createElement(K, r({}, e$1, { name: "Circle" })), !0, ["Circle"]))), et = x(l(d((e$1) => /* @__PURE__ */ import_react.createElement(K, r({}, e$1, { name: "Placemark" })), !0, ["Placemark"]))), nt = x(l(d((e$1) => /* @__PURE__ */ import_react.createElement(K, r({}, e$1, { name: "Polygon" })), !0, ["Polygon"]))), ot = x(l(d((e$1) => /* @__PURE__ */ import_react.createElement(K, r({}, e$1, { name: "Polyline" })), !0, ["Polyline"]))), st = x(l(d((e$1) => /* @__PURE__ */ import_react.createElement(K, r({}, e$1, { name: "Rectangle" })), !0, ["Rectangle"])));

//#endregion
export { D as Button, tt as Circle, V as Clusterer, B as FullscreenControl, X as GeoObject, A as GeolocationControl, L as ListBox, $ as ListBoxItem, k as Map, J as ObjectManager, T as Panorama, et as Placemark, nt as Polygon, ot as Polyline, st as Rectangle, N as RouteButton, Z as RouteEditor, z as RoutePanel, G as RulerControl, I as SearchControl, W as TrafficControl, F as TypeSelector, y as YMaps, q as ZoomControl, p as useYMaps, d as withYMaps };
//# sourceMappingURL=@pbe_react-yandex-maps.js.map